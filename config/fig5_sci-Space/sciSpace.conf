[general]
# general: general settings
#     In this section, you can set general settings such as project directory and name.
#     This section is required.

# Working directory
PROJECT_DIR= ~/files/m768/kijima.yusuke/work/sci-Space/Interstellar

# Path to template shellscript
SET_SHELL_ENV= ~/files/m768/kijima.yusuke/work/sci-Space/Interstellar//template.sh

# TSV file to indicate the sample correspondence if the input datasets consist of multiple samples
SAMPLESHEET= ~/files/m768/kijima.yusuke/work/sci-Space/whitelist/samplesheet.exp2.txt





[value_extraction]
# value_extraction: sequence segmentation and value extraction
#     In this section, sequence segmentation, sequence segment error-correction, and
#     sequence-to-value conversion are performed. This section is required.

# Input file path
READ1_DIR= ~/files/m768/kijima.yusuke/work/sci-Space/fastq_exp2_lns/R1/
READ2_DIR= ~/files/m768/kijima.yusuke/work/sci-Space/fastq_exp2_lns/R2/
INDEX1_DIR=
INDEX2_DIR=

# Paired-end reads to be merged by FLASH2. Skip if you don't need to merge.
# FLASH=READ1-READ2

# Minimum overlap length for the FLASH2 option "-m". Skip if you don't need to merge.
# FLASH_MIN_OVERLAP=20

# Maximum overlap length for the FLASH2 option "-M". Skip if you don't need to merge.
# FLASH_MAX_OVERLAP=30

# Read structure patterns by regular expression
READ1_STRUCTURE=^(?P<seg_umi>.{8})(?P<seg_cb>.{10}).*$
READ2_STRUCTURE_1=^(?P<seg_hash>.{10}).AAAAAAAAAA.*$
READ2_STRUCTURE_2=^(?P<seg_bio>.*)$
INDEX1_STRUCTURE=
INDEX2_STRUCTURE=

# You can add additional read structures
# READ1_STRUCTURE_2=[regular expression patterns]
# READ1_STRUCTURE_3=[regular expression patterns]

# If reads are merged by FLASH2 and searching for three different read structures
# READ_FLASH_STRUCTURE_1=[regular expression patterns]
# READ_FLASH_STRUCTURE_2=[regular expression patterns]
# READ_FLASH_STRUCTURE_3=[regular expression patterns]

# Parental-local variable allocations
# segment2=CHILD_OF(segment1)

# Sequence filtering and correction for each segment
# Available functions
#     - QUALITY_FILTER(source:..., min_base_score:5, min_avg_score:20)
#       Filtering out sequences that do not meet the condition.
#       * source: Target raw segment name
#       * min_base_score: Minimum allowable quality score across all bases in the segment. Default=5.
#       * min_avg_score: Minimum allowable average quality score of the segment. Default=20.
#     - PASS(source:...)
#       Skip all processes of quality filtering, sequence error-correction and value conversion 
#       for the target segment.
#       * source: Target raw segment name
#     - KNEE_CORRECT(rank:auto, dist:1)
#       Perform sequence error-correction based on the knee point on the rank-count plot.
#       * source: Target raw segment name
#       * rank: Method to determine the rank corresponding to the knee point in the rank-count plot. 
#               If ‘auto’ is specified, the knee point is automatically computed by kneed library. 
#               A numerical value can also be provided to manually indicate the rank for the knee point. 
#               Default=auto.
#       * dist: Maximum Levenshtein distance to error-correct the minority sequences compared
#               with the nearest sequences in the majority sequence population. Default=1.
#     - WHITELIST_CORRECT(path:..., dist:1)
#       Perform sequence error-correction based on the sequence whitelist.
#       * source: Target raw segment name
#       * path: Path to the sequence whitelist
#       * dist: Maximum Levenshtein distance to error-correct the minority sequences compared 
#               with the nearest sequences in the majority sequence population. Default=1.
#     - BARTENDER()
#       Perform sequence error-correction by Bartender.
#       * source: Target raw segment name
#       * -c: The sequence frequency cutoff.
#       * -d: The maximum cluster distance that may be merged.
#       * -z: The cluster merging threshold.
#       * -l: The seed length.
#       * -s:  The number of non-overlapping positions between two adjacent seeds.
#     - VALUE()
#       Convert sequence into value for the segment. This process is required if the segment is supposed 
#       to be converted in the value_translation step.
#       * source: Target raw segment name
cb_clean =QUALITY_FILTER(source:seg_cb, min_nucleotide_Q-score:5, min_avg_Q-score:20) >> WHITELIST_CORRECT(levenshtein_distance:1,path:~/files/m768/kijima.yusuke/work/sci-Space/whitelist/CB/RT.whitelist) >> SEQ2VALUE()
umi_clean=QUALITY_FILTER(source:seg_umi, min_nucleotide_Q-score:5, min_avg_Q-score:20) 
bio_clean=QUALITY_FILTER(source:seg_bio, min_nucleotide_Q-score:5, min_avg_Q-score:20)





[value_translation]
# value_translation: value to destination
#     In this section, the values are optimized and FASTQ files with specified read
#     structures are exported. To section is required to execute read translation.

#Value to destination sequence conversion
# Available functions
#     - WHITELIST_ASSIGNMENT(source:..., path:..., correspondence_table:...)
#       Assign sequences from a given whitelist to the destination segment. 
#       * source: Target clean segment name. To set the source as combination of multiple 
#                 clean segments, specify those segments split by “,”.
#       * path: Path to the whitelist. If multiple destination segments are defined, 
#               the same number of whitelists with the destination segments must be 
#               provided by splitting the paths by “,”.
#       * correspondence_table: Path to a tsv file that specifies the sequence correspondence
#                               between the clean segment and the destination segment. 
#     - RANDSEQ_ASSIGNMENT(source:..., length:)
#       Assign sequences from a random sequence set of a given length to the destination segment. 
#       * source: Target clean segment name. To set the source as combination of multiple 
#                 clean segments, specify those segments split by “,”.
#       * length: Sequence length. If multiple destination segments are defined, the same number 
#                 of this parameter with that of destination segments must be provided by splitting 
#                 the lengths by “,”. Each sequence length corresponds to each destination segment 
#                 in the same order.
#     - CONSTANT(sequence:...)
#       Assign constant sequences to the destination segment.
#       * sequence: Constant sequence.
#     - PASS(source:...)
#       Transfer the source sequences in the source segment.
#       * source: Target clean segment name.
#       * length: Adjust the source sequence to this length. Only trimming from the 3' end is available.
dest_segment1=VALUE2SEQ(source:cb_clean, whitelist_path:~/files/m96b/kijima.yusuke/work/Interstellar/dataset/10x/10x_3M-february-2018.txt)
dest_segment2=umi_clean
dest_segment3=bio_clean
dest_segment4="ATGC"

#Read structure configuration
READ1_STRUCTURE=dest_segment1+dest_segment2+dest_segment4
READ2_STRUCTURE=dest_segment3
