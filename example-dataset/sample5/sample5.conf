[general]
# general: general settings
#     In this section, you can set general settings such as project directory and name.
#     This section is required.

# Working directory
PROJECT_DIR=/path/to/project_dir

# Path to template shellscript
TEMPLATE_SHELLSCRIPT=/path/to/template.sh

# TSV file to indicate the sample correspondence if the input datasets consist of multiple samples
SAMPLESHEET=

#Number of records per split FASTQ file when the distributed computing mode is enabled
CHUNKSIZE=2000000





[value_extraction]
# value_extraction: sequence segmentation and value extraction
#     In this section, sequence segmentation, sequence segment error-correction, and
#     sequence-to-value conversion are performed. This section is required.

# Input file path
READ1_DIR=/path/to/Interstellar/example-dataset/sample5/R1
READ2_DIR=/path/to/Interstellar/example-dataset/sample5/R2
INDEX1_DIR=
INDEX2_DIR=

# Paired-end reads to be merged by FLASH2. Skip if you don't need to merge.
FLASH=READ1-READ2

# Minimum overlap length for the FLASH2 option "-m". Skip if you don't need to merge.
FLASH_MIN_OVERLAP=20

# Maximum overlap length for the FLASH2 option "-M". Skip if you don't need to merge.
FLASH_MAX_OVERLAP=100

# Read structure patterns by regular expression
# READ1_STRUCTURE=[regular expression patterns]
# READ2_STRUCTURE=[regular expression patterns]
# INDEX1_STRUCTURE=
# INDEX2_STRUCTURE=

# You can add additional read structures
# READ1_STRUCTURE_2=[regular expression patterns]
# READ1_STRUCTURE_3=[regular expression patterns]

# If reads are merged by FLASH2 and searching for three different read structures
READ_FLASH_STRUCTURE_1=^.+(?P<plate1>.{9})(?P<PS1>TAACTTACGGAGTCGCTCTACG){s<=1}(?P<row_idx>.{9})(?P<DBU1>CCATACGAGCACATTACGGG){s<=2}(?P<bc1>.+)(?P<DBU2>CTAACTCGCATACCTCTGATAAC){s<=2}(?P<lox2272>.+)(?P<DBlox2272>TGTCAGCACTCTGTCAAAATAGATCG){s<=2}....(?P<DBD1>TCGATAGGTGCGTGTGAAGG){s<=2}(?P<bc2>.+)(?P<DBD2>CCTCAGTCGCTCAGTCAAG){s<=2}(?P<col_idx>.{9})(?P<PS2>CAGGACCTAAAGAATCCCATCC){s<=1}(?P<plate2>.{9}).*$
READ_FLASH_STRUCTURE_2=^.+(?P<plate1>.{9})(?P<PS1>TAACTTACGGAGTCGCTCTACG){s<=1}(?P<row_idx>.{9})(?P<DBloxP>TTAAGTAAGTAATGGCAAACAGCTATTAT){s<=2}(?P<loxp>.+){s<=2}(?P<DBU1>CCATACGAGCACATTACGGG){s<=2}(?P<bc1>.+)(?P<DBU2>CTAACTCGCATACCTCTGATAAC){s<=2}(?P<lox2272>.+){s<=2}(?P<DBlox2272>TGTCAGCACTCTGTCAAAATAGATCG){s<=2}(?P<col_idx>.{9})(?P<PS2>CAGGACCTAAAGAATCCCATCC){s<=1}(?P<plate2>.{9}).*$
READ_FLASH_STRUCTURE_3=^.+(?P<plate1>.{9})(?P<PS1>TAACTTACGGAGTCGCTCTACG){s<=1}(?P<row_idx>.{9})(?P<ADU1>CCCTTAGAACCGAGAGTGTG){s<=2}(?P<bc1>.+)(?P<ADU2>CACTCCGTTCGTCACTCAATAA){s<=2}...(?P<ADloxP>CAGCACTCTGTCAAAATAGATCGGAAA){s<=2}(?P<loxp>.+){s<=2}(?P<ADD1>CTCCAGGGTTAGGCAGATG){s<=2}(?P<bc2>.+)(?P<ADD2>CAATCGCACTATCCCGCTG){s<=2}(?P<col_idx>.{9})(?P<PS2>CAGGACCTAAAGAATCCCATCC){s<=1}(?P<plate2>.{9}).*$
READ_FLASH_STRUCTURE_4=^.+(?P<plate1>.{9})(?P<PS1>TAACTTACGGAGTCGCTCTACG){s<=1}(?P<row_idx>.{9})(?P<ADloxP>CAGCACTCTGTCAAAATAGATCGG){s<=2}...(?P<loxp>.+){s<=2}(?P<ADD1>CTCCAGGGTTAGGCAGATG){s<=2}(?P<bc2>.+)(?P<ADD2>CAATCGCACTATCCCGCTG){s<=2}(?P<lox2272>.+){s<=2}(?P<ADlox2272>TTATGGGTATTATGGGTTAGGGATAACAGGGTAATAAGCTCTAAGTAAGTAACGGCCGCC){s<=3}(?P<col_idx>.{9})(?P<PS2>CAGGACCTAAAGAATCCCATCC){s<=1}(?P<plate2>.{9}).*$

# Parental-local variable allocations
# segment3=CHILD_OF(segment1,segment4)

# Sequence filtering and correction for each segment
# Available functions
#     - QUALITY_FILTER(source:..., min_base_score:5, min_avg_score:20)
#       Filtering out sequences that do not meet the condition.
#       * source: Target raw segment name
#       * min_base_score: Minimum allowable quality score across all bases in the segment. Default=5.
#       * min_avg_score: Minimum allowable average quality score of the segment. Default=20.
#     - PASS(source:...)
#       Skip all processes of quality filtering, sequence error-correction and value conversion 
#       for the target segment.
#       * source: Target raw segment name
#     - KNEE_CORRECT(rank:auto, dist:1)
#       Perform sequence error-correction based on the knee point on the rank-count plot.
#       * source: Target raw segment name
#       * rank: Method to determine the rank corresponding to the knee point in the rank-count plot. 
#               If ‘auto’ is specified, the knee point is automatically computed by kneed library. 
#               A numerical value can also be provided to manually indicate the rank for the knee point. 
#               Default=auto.
#       * dist: Maximum Levenshtein distance to error-correct the minority sequences compared
#               with the nearest sequences in the majority sequence population. Default=1.
#     - WHITELIST_CORRECT(path:..., dist:1)
#       Perform sequence error-correction based on the sequence whitelist.
#       * source: Target raw segment name
#       * path: Path to the sequence whitelist
#       * dist: Maximum Levenshtein distance to error-correct the minority sequences compared 
#               with the nearest sequences in the majority sequence population. Default=1.
#     - BARTENDER()
#       Perform sequence error-correction by Bartender.
#       * source: Target raw segment name
#       * -c: The sequence frequency cutoff.
#       * -d: The maximum cluster distance that may be merged.
#       * -z: The cluster merging threshold.
#       * -l: The seed length.
#       * -s:  The number of non-overlapping positions between two adjacent seeds.
#     - VALUE()
#       Convert sequence into value for the segment. This process is required if the segment is supposed 
#       to be converted in the value_translation step.
#       * source: Target raw segment name
s_plate1 = QUALITY_FILTER(source:plate1,min_base_score:10,min_avg_score:20) >> WHITELIST_CORRECT(dist:1, path:/path/to/example-dataset/whitelists/rcppcr_illumina_idx.txt)
s_plate2 = QUALITY_FILTER(source:plate2,min_base_score:10,min_avg_score:20) >> WHITELIST_CORRECT(dist:1, path:/path/to/example-dataset/whitelists/rcppcr_illumina_idx.txt)
s_row_idx = QUALITY_FILTER(source:row_idx,min_base_score:10,min_avg_score:20) >> WHITELIST_CORRECT(dist:1, path:/path/to/example-dataset/whitelists/rcppcr_illumina_idx.txt)
s_col_idx = QUALITY_FILTER(source:col_idx,min_base_score:10,min_avg_score:20) >> WHITELIST_CORRECT(dist:1, path:/path/to/example-dataset/whitelists/rcppcr_illumina_idx.txt)

s_bc1=QUALITY_FILTER(source:bc1,min_base_score:10,min_avg_score:20)
s_bc2=QUALITY_FILTER(source:bc2,min_base_score:10,min_avg_score:20)
s_lox2272=QUALITY_FILTER(source:lox2272,min_base_score:10,min_avg_score:20)
s_DBlox2272=QUALITY_FILTER(source:DBlox2272,min_base_score:10,min_avg_score:20)
s_DBloxP=QUALITY_FILTER(source:DBloxP,min_base_score:10,min_avg_score:20)
s_ADloxP=QUALITY_FILTER(source:ADloxP,min_base_score:10,min_avg_score:20)
s_loxp=QUALITY_FILTER(source:loxp,min_base_score:10,min_avg_score:20)
s_ADlox2272=QUALITY_FILTER(source:ADlox2272,min_base_score:10,min_avg_score:20)





[demultiplex]
# demultiplex: value to destination
#     In this section, using the clean segment table generated by the value extraction step, sequencing reads 
#     are split by user-defined variable segments as an output format of FASTQ or tsv.

# Clean segment names separating the file.
KEY=s_plate1,s_plate2,s_row_idx,s_col_idx

# Export data format, fastq or tsv
FORMAT=tsv

# Clean setgment names to be included in the demultiplexed sequence table if FORMAT=tsv.
TARGET=s_bc1,s_bc2,s_lox2272,s_DBlox2272,s_DBloxP,s_ADloxP,s_loxp,s_ADlox2272

# Output read structure if FORMAT=fastq
# READ1_STRUCTURE=cb_clean1+cb_clean2+umi_clean
# READ2_STRUCTURE=bio_clean
# INDEX1_STRUCTURE=
# INDEX2_STRUCTURE=
