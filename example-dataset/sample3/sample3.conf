[general]
# general: general settings
#     In this section, you can set general settings such as project directory and name.
#     This section is required.

# Working directory
PROJECT_DIR=/path/to/project_dir

# Path to template shellscript
TEMPLATE_SHELLSCRIPT=/path/to/template.sh

# TSV file to indicate the sample correspondence if the input datasets consist of multiple samples
SAMPLESHEET=/path/to/example-dataset/sample3/samplesheet.tsv

#Number of records per split FASTQ file when the distributed computing mode is enabled
CHUNKSIZE=2000000





[value_extraction]
# value_extraction: sequence segmentation and value extraction
#     In this section, sequence segmentation, sequence segment error-correction, and
#     sequence-to-value conversion are performed. This section is required.

# Input file path
READ1_DIR=/path/to/Interstellar/example-dataset/sample3/R1
READ2_DIR=/path/to/Interstellar/example-dataset/sample3/R2
INDEX1_DIR=
INDEX2_DIR=

# Paired-end reads to be merged by FLASH2. Skip if you don't need to merge.
# FLASH=READ1-READ2

# Minimum overlap length for the FLASH2 option "-m". Skip if you don't need to merge.
# FLASH_MIN_OVERLAP=20

# Maximum overlap length for the FLASH2 option "-M". Skip if you don't need to merge.
# FLASH_MAX_OVERLAP=30

# Read structure patterns by regular expression
READ1_STRUCTURE=^(?P<segment1>.{14})(?P<segment2>.{8}).*$
READ2_STRUCTURE=^(?P<segment3>.*)$
INDEX1_STRUCTURE=
INDEX2_STRUCTURE=

# You can add additional read structures
# READ1_STRUCTURE_2=[regular expression patterns]
# READ1_STRUCTURE_3=[regular expression patterns]

# If reads are merged by FLASH2 and searching for three different read structures
# READ_FLASH_STRUCTURE_1=[regular expression patterns]
# READ_FLASH_STRUCTURE_2=[regular expression patterns]
# READ_FLASH_STRUCTURE_3=[regular expression patterns]

# Parental-local variable allocations
segment2=CHILD_OF(segment1)

# Sequence filtering and correction for each segment
# Available functions
#     - QUALITY_FILTER(source:..., min_base_score:5, min_avg_score:20)
#       Filtering out sequences that do not meet the condition.
#       * source: Target raw segment name
#       * min_base_score: Minimum allowable quality score across all bases in the segment. Default=5.
#       * min_avg_score: Minimum allowable average quality score of the segment. Default=20.
#     - PASS(source:...)
#       Skip all processes of quality filtering, sequence error-correction and value conversion 
#       for the target segment.
#       * source: Target raw segment name
#     - KNEE_CORRECT(rank:auto, dist:1)
#       Perform sequence error-correction based on the knee point on the rank-count plot.
#       * source: Target raw segment name
#       * rank: Method to determine the rank corresponding to the knee point in the rank-count plot. 
#               If ‘auto’ is specified, the knee point is automatically computed by kneed library. 
#               A numerical value can also be provided to manually indicate the rank for the knee point. 
#               Default=auto.
#       * dist: Maximum Levenshtein distance to error-correct the minority sequences compared
#               with the nearest sequences in the majority sequence population. Default=1.
#     - WHITELIST_CORRECT(path:..., dist:1)
#       Perform sequence error-correction based on the sequence whitelist.
#       * source: Target raw segment name
#       * path: Path to the sequence whitelist
#       * dist: Maximum Levenshtein distance to error-correct the minority sequences compared 
#               with the nearest sequences in the majority sequence population. Default=1.
#     - BARTENDER()
#       Perform sequence error-correction by Bartender.
#       * source: Target raw segment name
#       * -c: The sequence frequency cutoff.
#       * -d: The maximum cluster distance that may be merged.
#       * -z: The cluster merging threshold.
#       * -l: The seed length.
#       * -s:  The number of non-overlapping positions between two adjacent seeds.
#     - VALUE()
#       Convert sequence into value for the segment. This process is required if the segment is supposed 
#       to be converted in the value_translation step.
#       * source: Target raw segment name
cb_clean =QUALITY_FILTER(source:segment1, min_base_score:5, min_avg_score:20) >> WHITELIST_CORRECT(dist:1,path:/path/to/Interstellar/example-dataset/whitelists/CellBarcode_QuartzSeq2_v31.txt) >> VALUE()
umi_clean=QUALITY_FILTER(source:segment2, min_base_score:5, min_avg_score:20) >> VALUE()
bio_clean=QUALITY_FILTER(source:segment3, min_base_score:5, min_avg_score:20)





[value_translation]
# value_translation: value to destination
#     In this section, the values are optimized and FASTQ files with specified read
#     structures are exported. To section is required to execute read translation.

#Value to destination sequence conversion
# Available functions
#     - WHITELIST_ASSIGNMENT(source:..., path:..., correspondence_table:...)
#       Assign sequences from a given whitelist to the destination segment. 
#       * source: Target clean segment name. To set the source as combination of multiple 
#                 clean segments, specify those segments split by “,”.
#       * path: Path to the whitelist. If multiple destination segments are defined, 
#               the same number of whitelists with the destination segments must be 
#               provided by splitting the paths by “,”.
#       * correspondence_table: Path to a tsv file that specifies the sequence correspondence
#                               between the clean segment and the destination segment. 
#     - RANDSEQ_ASSIGNMENT(source:..., length:)
#       Assign sequences from a random sequence set of a given length to the destination segment. 
#       * source: Target clean segment name. To set the source as combination of multiple 
#                 clean segments, specify those segments split by “,”.
#       * length: Sequence length. If multiple destination segments are defined, the same number 
#                 of this parameter with that of destination segments must be provided by splitting 
#                 the lengths by “,”. Each sequence length corresponds to each destination segment 
#                 in the same order.
#     - CONSTANT(sequence:...)
#       Assign constant sequences to the destination segment.
#       * sequence: Constant sequence.
#     - PASS(source:...)
#       Transfer the source sequences in the source segment.
#       * source: Target clean segment name.
#       * length: Adjust the source sequence to this length. Only trimming from the 3' end is available.
dest_segment1,dest_segment2,dest_segment3=WHITELIST_ASSIGNMENT(source:cb_clean, path:/path/to/Interstellar/example-dataset/whitelists/split.round1.raw.txt,/path/to/Interstellar/example-dataset/whitelists/split.round2.raw.txt,/path/to/Interstellar/example-dataset/whitelists/split.round3.raw.txt)
dest_segment4=RANDSEQ_ASSIGNMENT(source:umi_clean, length:10)
dest_segment5=PASS(source:bio_clean)
dest_segment6=CONSTANT(sequence:GTGGCCGATGTTTCGCATCGGCGTACGACT)
dest_segment7=CONSTANT(sequence:ATCCACGTGCTTGAGAGGCCAGAGCATTCG)

#Read structure configuration
READ1_STRUCTURE=dest_segment4+dest_segment3+dest_segment6+dest_segment2+dest_segment7+dest_segment1
READ2_STRUCTURE=dest_segment5