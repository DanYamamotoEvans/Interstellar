[general]
# general: general settings
#     In this section, you can set general settings such as project directory and name.
#     This section is required.

# Working directory
PROJECT_DIR=/path/to/project_dir

# Path to template shellscript
TEMPLATE_SHELLSCRIPT=/path/to/template.sh

# TSV file to indicate the sample correspondence if the input datasets consist of multiple samples
SAMPLESHEET=

#Number of records per split FASTQ file when the distributed computing mode is enabled
CHUNKSIZE=2000000





[value_extraction]
# value_extraction: sequence segmentation and value extraction
#     In this section, sequence segmentation, sequence segment error-correction, and
#     sequence-to-value conversion are performed. This section is required.

# Input file path
READ1_DIR=/FASTQ/path/to/R1
READ2_DIR=/FASTQ/path/to/R2
INDEX1_DIR=
INDEX2_DIR=

# Paired-end reads to be merged by FLASH2. Skip if you don't need to merge.
FLASH=READ1-READ2

# Minimum overlap length for the FLASH2 option "-m". Skip if you don't need to merge.
FLASH_MIN_OVERLAP=20

# Maximum overlap length for the FLASH2 option "-M". Skip if you don't need to merge.
FLASH_MAX_OVERLAP=30

# Read structure patterns by regular expression
READ1_STRUCTURE=[regular expression patterns]
READ2_STRUCTURE=[regular expression patterns]
INDEX1_STRUCTURE=
INDEX2_STRUCTURE=

# You can add additional read structures
READ1_STRUCTURE_2=[regular expression patterns]
READ1_STRUCTURE_3=[regular expression patterns]

# If reads are merged by FLASH2 and searching for three different read structures
READ_FLASH_STRUCTURE_1=[regular expression patterns]
READ_FLASH_STRUCTURE_2=[regular expression patterns]
READ_FLASH_STRUCTURE_3=[regular expression patterns]

# Parental-local variable allocations
segment3=CHILD_OF(segment1,segment4)

# Sequence filtering and correction for each segment
# Available functions
#     - QUALITY_FILTER(source:..., min_base_score:5, min_avg_score:20)
#       Filtering out sequences that do not meet the condition.
#       * source: Target raw segment name
#       * min_base_score: Minimum allowable quality score across all bases in the segment. Default=5.
#       * min_avg_score: Minimum allowable average quality score of the segment. Default=20.
#     - PASS(source:...)
#       Skip all processes of quality filtering, sequence error-correction and value conversion 
#       for the target segment.
#       * source: Target raw segment name
#     - KNEE_CORRECT(rank:auto, dist:1)
#       Perform sequence error-correction based on the knee point on the rank-count plot.
#       * source: Target raw segment name
#       * rank: Method to determine the rank corresponding to the knee point in the rank-count plot. 
#               If ‘auto’ is specified, the knee point is automatically computed by kneed library. 
#               A numerical value can also be provided to manually indicate the rank for the knee point. 
#               Default=auto.
#       * dist: Maximum Levenshtein distance to error-correct the minority sequences compared
#               with the nearest sequences in the majority sequence population. Default=1.
#     - WHITELIST_CORRECT(path:..., dist:1)
#       Perform sequence error-correction based on the sequence whitelist.
#       * source: Target raw segment name
#       * path: Path to the sequence whitelist
#       * dist: Maximum Levenshtein distance to error-correct the minority sequences compared 
#               with the nearest sequences in the majority sequence population. Default=1.
#     - BARTENDER()
#       Perform sequence error-correction by Bartender.
#       * source: Target raw segment name
#       * -c: The sequence frequency cutoff.
#       * -d: The maximum cluster distance that may be merged.
#       * -z: The cluster merging threshold.
#       * -l: The seed length.
#       * -s:  The number of non-overlapping positions between two adjacent seeds.
#     - VALUE()
#       Convert sequence into value for the segment. This process is required if the segment is supposed 
#       to be converted in the value_translation step.
#       * source: Target raw segment name
cb_clean1=QUALITY_FILTER(source:segment1, min_base_score:5, min_avg_score:20) >> WHITELIST_CORRECT(dist:1, path:/paht/to/whitelist1.txt) >> VALUE()
cb_clean2=QUALITY_FILTER(source:segment4, min_base_score:5, min_avg_score:20) >> WHITELIST_CORRECT(dist:1, path:/paht/to/whitelist2.txt) >> VALUE()
const=PASS(source:segment2)
umi_clean=QUALITY_FILTER(source:segment3, min_base_score:5, min_avg_score:20) >> VALUE()
bio_clean=QUALITY_FILTER(source:segment5, min_base_score:5, min_avg_score:20)





[value_translation]
# value_translation: value to destination
#     In this section, the values are optimized and FASTQ files with specified read
#     structures are exported. To section is required to execute read translation.

#Value to destination sequence conversion
# Available functions
#     - WHITELIST_ASSIGNMENT(source:..., path:..., correspondence_table:...)
#       Assign sequences from a given whitelist to the destination segment. 
#       * source: Target clean segment name. To set the source as combination of multiple 
#                 clean segments, specify those segments split by “,”.
#       * path: Path to the whitelist. If multiple destination segments are defined, 
#               the same number of whitelists with the destination segments must be 
#               provided by splitting the paths by “,”.
#       * correspondence_table: Path to a tsv file that specifies the sequence correspondence
#                               between the clean segment and the destination segment. 
#     - RANDSEQ_ASSIGNMENT(source:..., length:)
#       Assign sequences from a random sequence set of a given length to the destination segment. 
#       * source: Target clean segment name. To set the source as combination of multiple 
#                 clean segments, specify those segments split by “,”.
#       * length: Sequence length. If multiple destination segments are defined, the same number 
#                 of this parameter with that of destination segments must be provided by splitting 
#                 the lengths by “,”. Each sequence length corresponds to each destination segment 
#                 in the same order.
#     - CONSTANT(sequence:...)
#       Assign constant sequences to the destination segment.
#       * sequence: Constant sequence.
#     - PASS(source:...)
#       Transfer the source sequences in the source segment.
#       * source: Target clean segment name.
#       * length: Adjust the source sequence to this length. Only trimming from the 3' end is available.
dest_segment1=WHITELIST_ASSIGNMENT(source:cb_clean1,cb_clean2, path:/paht/to/whitelist.txt)
dest_segment2=RANDSEQ_ASSIGNMENT(source:umi_clean, length:12)
dest_segment3=PASS(source:bio_clean,length:)

#Read structure configuration
READ1_STRUCTURE=dest_segment1+dest_segment2
READ2_STRUCTURE=dest_segment3





[demultiplex]
# demultiplex: value to destination
#     In this section, using the clean segment table generated by the value extraction step, sequencing reads 
#     are split by user-defined variable segments as an output format of FASTQ or tsv.

# Clean segment names separating the file.
KEY=cb_clean1,cb_clean2

# Export data format, fastq or tsv
FORMAT=fastq

# Clean setgment names to be included in the demultiplexed sequence table if FORMAT=tsv.
TARGET=

# Output read structure if FORMAT=fastq
READ1_STRUCTURE=cb_clean1+cb_clean2+umi_clean
READ2_STRUCTURE=bio_clean
INDEX1_STRUCTURE=
INDEX2_STRUCTURE=






[tag]
# tag: value to destination
#     In this section, using the clean segment table generated by the value extraction step, user-defined segments 
#     are tagged on header lines of the FASTQ files with user-defined read structures.

# Clean segment names to be tagged on the output FASTQ headers.
READ1_TAG=cb_value1,cb_value2
READ2_TAG=
INDEX1_TAG=cb_value1,cb_value2,umi_value3
INDEX2_TAG=

# Out0put read structure
READ1_STRUCTURE=cb_value1+umi_value3
READ2_STRUCTURE=
INDEX1_STRUCTURE=const_value4+bio_value5
INDEX2_STRUCTURE=
