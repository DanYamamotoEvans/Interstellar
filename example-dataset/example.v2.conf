[general]
# general: general settings
#     In this section, you can set general settings such as project directory and name
PROJECT_NAME=test
PROJECT_DIR=~/work/yachie/YUSUKE_KIJIMA.LAB/Experiments/Projects/inter_test
TEMPLATE_SHELLSCRIPT=/Users/yusukekijima/work/yachie/YUSUKE_KIJIMA.LAB/Experiments/Projects/inter_test/template.sh
SAMPLESHEET=
CHUNKSIZE=2000000





[value_extraction]
# value_extraction: sequence to value
#     In this section, the input FASTQ files are segmented, sequence segments 
#     are error-corrected and values are generated.
#     If you just want to obtain a value matrix or error-corrected seuence 
#     segment table, only having this section is fine.

# Input file path
READ1_DIR=~/work/yachie/YUSUKE_KIJIMA.LAB/Experiments/Projects/dnaSynergizer/example-dataset/fastqs/R1
READ2_DIR=~/work/yachie/YUSUKE_KIJIMA.LAB/Experiments/Projects/dnaSynergizer/example-dataset/fastqs/R2
INDEX1_DIR=
INDEX2_DIR=

# If you want to merge paired-reads FASTQs by FLASH. Ignore if you don't want.
# FLASH=READ1-READ2
# FLASH_MIN_OVERLAP=20
# FLASH_MAX_OVERLAP=30

# Read structure configuration
READ1_STRUCTURE=^(?P<segment1>.{9,10})(?P<segment2>CAGAGC){s<=2}(?P<segment3>.{8})(?P<segment4>.{10}).*$
READ2_STRUCTURE=(?P<segment5>.*)
INDEX1_STRUCTURE=
INDEX2_STRUCTURE=
# READ1_STRUCTURE_2=^(?P<segment1>.{9,10})(?P<segment2>CAGAGC){s<=2}(?P<segment3>.{8})(?P<segment4>.{10}).*$ #If you want to look for other read structure
# READ1_STRUCTURE_3=^(?P<segment1>.{9,10})(?P<segment2>CAGAGC){s<=2}(?P<segment3>.{8})(?P<segment4>.{10}).*$ #If you want to look for other read structure
# READ_FLASH_STRUCTURE_1=^(?P<segment1>.{9,10})(?P<segment2>CAGAGC){s<=2}(?P<segment3>.{8})(?P<segment4>.{10}).*$ #If you want to FLASH and look for other read structure
# READ_FLASH_STRUCTURE_2=^(?P<segment1>.{9,10})(?P<segment2>CAGAGC){s<=2}(?P<segment3>.{8})(?P<segment4>.{10}).*$ #If you want to FLASH and look for other read structure
# READ_FLASH_STRUCTURE_3=^(?P<segment1>.{9,10})(?P<segment2>CAGAGC){s<=2}(?P<segment3>.{8})(?P<segment4>.{10}).*$ #If you want to FLASH and look for other read structure

# Parental-local variable allocations
segment3=CHILD_OF(segment1,segment4)
#segment1,segment4=CHILD_OF(segmentx)

# Sequence filtering and correction for each segment
# Available functions
#     - QUALITY_FILTER(source:..., min_base_score:5, min_avg_score:20)
#       Filtering out sequences that do not meet the condition. 
#       * source: target segment name
#       * min_base_score: minimum allowable quality score for all bases
#       * min_avg_score: minimum avarage quality score for the sequence segment
#     - PASS(source:..., length:)
#       Do not perform quality filtering, sequence correction and value conversion for the segment. 
#       * source: target segment name
#     - KNEE_CORRECT(rank:auto, dist:1)
#       Perform sequence error-correction based on the knee point on the rank-count plot.
#       * source: target segment name
#       * rank: If 'auto' is specified, the knee point is automatically computed. A numerical 
#               value can also be specified to manually determine the rank for the knee point.
#       * dist: Maximum Levenshtein distance to error-correct the minority sequences comparing 
#               with the best-match sequences in the majority sequence population. 
#     - WHITELIST_CORRECT(path:..., dist:1)
#       Perform sequence error-correction based on the sequence whitelist.
#       * source: target segment name
#       * path: sequence whitelist path
#       * dist: Maximum Levenshtein distance to error-correct the sequences comparing with
#               the best-match sequences in the whitelist. 
#     - BARTENDER()
#       Perform sequence error-correction by Bartender.
#       * source: target segment name
#       * -c: the frequency cutoff.
#       * -d: The maximum cluster distance that may be merged.
#       * -z: The cluster merging threshold.
#       * -l: The seed length.
#       * -s:  The number of non-overlapping positions between two adjacent seeds.
#     - VALUE()
#       Convert sequence into value for the segment.
#       * source: target segment name

cb_value1=QUALITY_FILTER(source:segment1, min_base_score:5, min_avg_score:20) >> KNEE_CORRECT(rank:auto, dist:1) >> WHITELIST_CORRECT(dist:1, path:example-dataset//sci-RNA-seq3_HP_purified_whitelist.txt) >> VALUE()
cb_value2=QUALITY_FILTER(source:segment4, min_base_score:5, min_avg_score:20) >> KNEE_CORRECT(rank:auto, dist:1) >> WHITELIST_CORRECT(dist:1, path:example-dataset//sci-RNA-seq3_RT_purified_whitelist.txt) >> VALUE()
const_value4=PASS(source:segment2)
umi_value3=QUALITY_FILTER(source:segment3, min_base_score:5, min_avg_score:20) >> VALUE()
bio_value5=QUALITY_FILTER(source:segment5, min_base_score:5, min_avg_score:20)






[value_translation]
# value_translation: value to destination
#     In this section, the values are optimized and FASTQ files with  
#     specified structures are exported. To excute this section, you
#     need the following settings.

#Value to destination sequence conversion
# Available functions
#     - WHITELIST_ASSIGNMENT(source:..., path:..., correspondence_table:...)
#       Assign destination table from a given whitelist. You can also correspond the souce sequence
#       to destination table specified in the correspondence table. 
#       * source: target source segment name. You can specify multiple source segments by comma-separation
#                 if the segment works in a combinatorial manner.
#       * path: Path for the whitelist.
#       * min_avg_score: minimum avarage quality score for the sequence segment
#     - RANDSEQ_ASSIGNMENT(source:..., length:)
#       Do not perform quality filtering for the segment. 
#       * source: target segment name
#       * length: adjust sequence length fot this value. Only trimming is available.
#       * add: nucleotide for tandem sequence extention
#     - CONSTANT(sequence:...)
#       Constant sequence 
#       * sequence: constant sequence
#     - PASS(source:...)
#       Transfer the source sequences in the source segment.
#       * source: source segment name.
#       * length: Adjust sequence length. Only trimming from 3' end is available.

dest_segment1=WHITELIST_ASSIGNMENT(source:cb_value1,cb_value2, path:../testout/3M-february-2018.txt, correspondence_table:)
dest_segment2=RANDSEQ_ASSIGNMENT(source:umi_value3, length:12)
dest_segment3=PASS(source:bio_value5,length:)

#Read structure configuration
READ1_STRUCTURE=dest_segment1+dest_segment2
READ2_STRUCTURE=dest_segment3






[demultiplex]
KEY=cb_value1,cb_value2
TARGET=
FORMAT=fastq
READ1_STRUCTURE=cb_value1+umi_value3
READ2_STRUCTURE=const_value4+bio_value5






[tag]
READ1_TAG=cb_value1,cb_value2
READ2_TAG=
INDEX1_TAG=cb_value1,cb_value2,umi_value3
INDEX2_TAG=
READ1_STRUCTURE=cb_value1+umi_value3
READ2_STRUCTURE=
INDEX1_STRUCTURE=const_value4+bio_value5
INDEX2_STRUCTURE=